"""
Restrictions and (Geo)Features that are using them..
"""
from __future__ import annotations
import logging
import math
from typing import List

from emitpy.constants import FEATPROP

from emitpy.geo.turf import destination, Point, Feature
from emitpy.geo import FeatureWithProps

from emitpy.utils import cifp_alt_in_ft, cifp_alt_in_fl, cifp_speed, toKn, toKmh2, toKmh, toMs, toMeter
from .aerospace import NamedPoint

logger = logging.getLogger("Restriction")


################################
#
# RESTRICTIONS
#
#
class Restriction:
    """
    A Restriction is an altitude and/or speed restriction for a section of an airspace.
    If a altitude restriction is set, an aircraft must fly above alt_min and/or below alt_max.
    If a speed restriction is set, the aircraft must fly fater than speed_min and/or slower than speed_max.
    If there is no restriction, use None for restriction.
    Consider this as a mixin.
    """

    def __init__(self, altmin: int | None = None, altmax: int | None = None, speed: int | None = None):
        self._source: "ProcedureData" | None = None
        # Altitude constrains
        self.alt1 = altmin  # In ft
        self.alt2 = altmax
        self.alt1_type: str | None = None  # MSL, AGL, UL
        self.alt2_type: str | None = None
        self.alt_restriction_type: str | None = None
        # Speed constrains
        self.restricted_speed: int | None = speed  # In kn
        self.speed_restriction_type: str | None = None
        # Bank angle constrains
        self.angle = None  # Bank angle in °.
        self.restrictions: List[Restriction] = []

    @staticmethod
    def parse(restriction):
        # Parses string generated by Desc() procedures
        # Altitude:
        # [ +-@]alt
        # Xalt,alt
        # X,alt
        # Speed:
        # /[ +-@]speed
        ar, sr = restriction.split("/")
        r = Restriction()
        # speed
        if sr != "":
            r.speed_restriction_type = sr[0]
            r.restricted_speed = cifp_speed(sr[1:])
        # alt
        if ar != "":
            r.alt_restriction_type = ar[0]
            if "," in ar:
                r.alt1, r.alt2 = ar[1:].split(",")
                if r.alt1 != "":
                    r.alt1 = cifp_alt_in_ft(r.alt1)
                if r.alt2 != "":
                    r.alt2 = cifp_alt_in_ft(r.alt2)
            else:
                r.alt1 = cifp_alt_in_ft(ar[1:])
        if restriction != r.getRestrictionDesc():
            logger.warning(f"parsed restriction '{restriction}' to '{r.getRestrictionDesc()}'")
        assert restriction == r.getRestrictionDesc()
        return r

    def getInfo(self):
        return {
            "type": type(self).__name__,
            "alt1": self.alt1,
            "alt2": self.alt2,
            "alt_desc": self.alt_restriction_type,
            "speed": self.restricted_speed,
            "speed_desc": self.speed_restriction_type,
        }

    def hasRestriction(self) -> bool:
        return self.hasAltitudeRestriction() or self.hasSpeedRestriction()

    def getRestrictionDesc(self, verbose: bool = False):
        if not self.hasAltitudeRestriction() and not self.hasSpeedRestriction() and verbose:
            return "no restriction"

        a = self.getAltitudeRestrictionDesc() + "/" + self.getSpeedRestrictionDesc()
        if self.angle is not None:
            a = a + f"/{self.angle}°"
        a = a.strip()
        return "" if a in ["/", "@/@"] else a

    def setAltitudeRestriction(self, altmin: int, altmax: int):
        self.alt1 = altmin
        self.alt2 = altmax

    def getAltitudeRestrictionDesc(self, use_fl: bool = True) -> str:
        a = ""
        if self.alt1 is not None:
            a = "?" if self.alt_restriction_type is None else self.alt_restriction_type
            if a == " ":
                a = "@"  # more explicit on display
            astr = f"{self.alt1}"
            if use_fl:
                astr = cifp_alt_in_fl(self.alt1)
            a = f"{a}{astr}"
            if self.alt2 is not None:
                astr = f"{self.alt2}"
                if use_fl:
                    astr = cifp_alt_in_fl(self.alt2)
                a = f"{a},{astr}"
        elif self.alt2 is not None:
            a = "?" if self.alt_restriction_type is None else self.alt_restriction_type
            if a == " ":
                a = "@"  # more explicit on display
            astr = f"{self.alt2}"
            if use_fl:
                astr = cifp_alt_in_fl(self.alt2)
            a = f"{a},{astr}"
        return a

    def hasAltitudeRestriction(self) -> bool:
        return self.alt1 is not None or self.alt2 is not None

    def checkAltitude(self, point: Point, tolerance: int = 30):
        # def checkAltitude(self, feature: Feature):
        #     point = feature["geometry"]
        if self.alt1 is None and self.alt2 is None:
            logger.debug("no alt constraints")
            return True
        if len(point.coordinates) < 3:  # no alt, must be ok ;-)
            return True
        alt = point.coordinates[2]
        if self.alt_restriction_type in ["@", " "]:
            return (alt - self.alt1) <= tolerance  # 30meters=100ft
        elif self.alt_restriction_type == "B":
            return self.alt1 <= alt <= self.alt2
        elif self.alt_restriction_type == "B":
            return alt >= self.alt2
        return True  # no restriction?

    def setSpeedRestriction(self, speed: int):
        """
        If there is no restriction, set speed to None.
        """
        self.restricted_speed = speed

    def getSISpeed(self):
        return toMs(kmh=toKmh(kn=self.restricted_speed))

    def getSIAltitudes(self):
        return (toMeter(ft=self.alt1) if self.alt1 is not None else None, toMeter(ft=self.alt2) if self.alt2 is not None else None)

    def getSpeedRestrictionDesc(self):
        a = ""
        if self.restricted_speed is not None:
            a = "?" if self.speed_restriction_type is None else self.speed_restriction_type
            if a == " ":
                a = "@"  # more explicit on display
            a = f"{a}{self.restricted_speed}"
        return a

    def hasSpeedRestriction(self) -> bool:
        return self.restricted_speed is not None

    def checkSpeed(self, feature: Feature, propname: str = FEATPROP.SPEED.value, tolerance: int = 5):
        """
        Note: We assume same units for feature speed and constrains.
        We also assume feature has properties dict set.
        """
        if self.restricted_speed is None:
            logger.debug("no speed constrains")
            return True
        speed = toKn(toKmh2(ms=feature.props().get(propname)))
        if speed is not None:
            if self.speed_restriction_type in [" ", "@"]:
                return (speed - self.restricted_speed) <= tolerance  # 5 m/s=18km/h=10kn
            elif self.speed_restriction_type == "-":
                return speed <= self.restricted_speed
            elif self.speed_restriction_type == "+":
                return speed >= self.restricted_speed
            else:
                logger.warning(f"invalid control speed type '{self.speed_restriction_type}'")
        return True

    def combine(self, restriction):
        def nvl(a, b):
            return a if a is not None else b

        self.restrictions.append(restriction)

        self.alt1 = min(nvl(self.alt1, math.inf), nvl(restriction.alt1, math.inf))
        if self.alt1 == math.inf:
            self.alt1 = None
        self.alt2 = max(nvl(self.alt2, 0), nvl(restriction.alt2, 0))
        if self.alt2 == 0:
            self.alt2 = None

        self.restricted_speed = max(nvl(self.restricted_speed, 0), nvl(restriction.restricted_speed, 0))
        if self.restricted_speed == 0:
            self.restricted_speed = None

        self.alt_restriction_type = nvl(self.alt_restriction_type, restriction.alt_restriction_type)
        self.speed_restriction_type = nvl(self.speed_restriction_type, restriction.speed_restriction_type)


################################
#
# CLASSES WITH RESTRICTION(S)
# Sometimes, Restriction is an aattribute of the class.
#
#
class FeatureWithRestriction(FeatureWithProps):
    """
    A NamedPoint with a Restriction attached to it.
    """

    def __init__(self, geometry, properties={}, **extra):
        FeatureWithProps.__init__(self, geometry=geometry, properties=properties, extra=extra)
        self.restrictions = []
        self.restriction = None

    def add_restriction(self, restriction):
        self.restrictions.append(restriction)
        if self.restriction is None:
            self.restriction = restriction
        else:
            self.restriction.combine(restriction)

    def has_restriction(self):
        return self.restriction is not None


class NamedPointWithRestriction(NamedPoint, Restriction):
    """
    A NamedPoint with a Restriction attached to it.
    A NamedPointWithRestriction is a combination of a NamedPoint and a Restriction.
    """

    def __init__(self, ident: str, region: str, airport: str, pointtype: str, lat: float, lon: float):
        NamedPoint.__init__(self, ident=ident, region=region, airport=airport, pointtype=pointtype, lat=lat, lon=lon)
        Restriction.__init__(self)


class ControlledAirspace(FeatureWithProps, Restriction):
    """
    This class describes a restricted airspace.
    A ControlledAirspace is a combination of a FeatureWithProps and a Restriction.
    @todo: we'll deal with the airspace restricted volumes later.
    @see: Little Navmap for "inspiration".
    """

    def __init__(self, name: str, region: str, airspace_class: str, area, altmin: int, altmax: int, altmin_type: str, altmax_type: str):
        FeatureWithProps.__init__(self, geometry=area, properties={})
        Restriction.__init__(self)

        self.airspace_class = airspace_class
        self.setAltitudeRestriction(altmin, altmax)
        self.alt1_type = altmin_type
        self.alt2_type = altmax_type

        self.airspace_class = airspace_class

    def add_restricton(self, restriction):
        self.combine(restriction)


class Hold(Restriction):
    """
    A Holding position. A Hold is a restriction with a fix attached to it.
        The course if the course (magnetic) of the inbound leg.
        Turn is Left or Right.
        Leg time is the duration of the leg or 0 for DME leg.
        Leg length is the length of the leg for DME leg or 0 for timed leg.
        Speed is the holding speed.
    """

    def __init__(self, fix: NamedPoint, altmin: int, altmax: int, course: float, turn: str, leg_time: float, leg_length: float, speed: int):
        Restriction.__init__(self)
        self.fix = fix
        self.course = course
        self.turn = turn
        self.leg_time = leg_time  # min
        self.leg_length = leg_length  # unit?
        self.setAltitudeRestriction(altmin, altmax)
        self.setSpeedRestriction(speed)

    def getInfo(self):
        return {
            "class": type(self).__name__,
            "restriction": super().getInfo(),
            "fix": self.fix.getInfo(),
            "course": self.course,
            "leg_time": self.leg_time,
            "leg_length": self.leg_length,
        }

    def getRoute(self, speed: float, finesse: int = 6):
        """
        Make path from Hold data and aircraft speed.
        Returns an array of Feature<Point>

        :param      speed:  The speed
        :type       speed:  float
        """

        def line_arc(center, radius, start, end, steps=8):
            arc = []
            if end < start:
                end = end + 360
            step = (end - start) / steps
            a = start
            while a < end:
                p = destination(center, radius, a + 180)
                arc.append(p)
                a = a + step
            return arc

        # leg length
        length = speed * self.leg_time * 60 if self.leg_time > 0 else self.leg_length
        length = length / 1000  # km
        # circle radius:
        radius = length / math.pi
        # step = 180 / finesse

        # logger.debug("spd=%f len=%f rad=%f turn=%s legt=%f legl=%f" % (speed, length, radius, self.turn, self.leg_time, self.leg_length))

        # 4 corners and 2 arc centers p1 -> p2 -> p3 -> p4 -> p1
        p1 = self.fix
        p2 = destination(p1, length, self.course)

        hold = [p1, p2]  # start from p1, to to p2, then 180 turn:

        perpendicular = self.course + 90 * (1 if self.turn == "R" else -1)
        c23 = destination(p2, radius, perpendicular)

        logger.debug(f"fix:{self.fix.id} turn={self.turn} course={self.course:f} perp={perpendicular:f}")

        start_angle = perpendicular
        if self.turn == "L":
            start_angle = start_angle - 180

        arc = line_arc(c23, radius, start_angle, start_angle + 180, finesse)
        if self.turn == "L":
            arc.reverse()
        hold = hold + arc

        p3 = destination(p2, 2 * radius, perpendicular)
        hold.append(p3)
        p4 = destination(p1, 2 * radius, perpendicular)
        hold.append(p4)

        c41 = destination(p1, radius, perpendicular)
        arc = line_arc(c41, radius, start_angle + 180, start_angle + 360, finesse)
        if self.turn == "L":
            arc.reverse()
        hold = hold + arc

        return hold
