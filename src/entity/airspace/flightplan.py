"""
A FlightPlan is a route from origin to destination using airways.
Flight plans are generated by the flightplandatabase.com site and cached in this application.
Origin and destination airport data is also cached.
"""
# curl -u vMzb5J3qtRnIo4CgdCqiGUsRhWEXpAHLMJj04Rds: -i https://api.flightplandatabase.com/
import os
import json
from geojson import Feature, LineString, Point, FeatureCollection
from ..constants import FOOT
from ..private import FLIGHT_PLAN_DATABASE_APIKEY
import flightplandb as fpdb
from flightplandb.datatypes import GenerateQuery
from .airspace import Airspace

import requests_cache

import logging

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger("FlightPlan")


class FlightPlan:
    def __init__(self, managedAirport: str, fromICAO: str, toICAO: str,
                 useNAT: bool = True, usePACOT: bool = True, useAWYLO: bool = True, useAWYHI: bool = True,
                 cruiseAlt: float = 35000, cruiseSpeed: float = 420,
                 ascentRate: float = 2500, ascentSpeed: float = 250,
                 descentRate: float = 1500, descentSpeed: float = 250,
                 force: bool = False):

        self.fromICAO = fromICAO
        self.toICAO = toICAO
        self.cruiseAlt = cruiseAlt
        self.cruiseSpeed = cruiseSpeed
        self.ascentRate = ascentRate
        self.ascentSpeed = ascentSpeed
        self.descentRate = descentRate
        self.descentSpeed = descentSpeed
        self.flight_plan = None
        self.route = None
        self.routeLS = None


        # creates file caches
        self.flightplan_cache = os.path.join("..", "data", "managedairport", managedAirport, "flightplans")
        if not os.path.exists(self.flightplan_cache):
            logger.warn("no file plan cache directory")
            #print("create new fpdb file cache")
            #os.mkdir(self.flightplan_cache)

        self.airports_cache = os.path.join("..", "data", "airports", "fpdb")
        if not os.path.exists(self.airports_cache):
            logger.warn("no airport cache directory")
            #print("create new fpdb file cache")
            #os.mkdir(self.flightplan_cache)

        self.filename = "%s-%s" % (fromICAO.lower(), toICAO.lower())
        self.api = fpdb.FlightPlanDB(FLIGHT_PLAN_DATABASE_APIKEY)

        # For development
        requests_cache.install_cache()

        self.cacheAirports()


    def toGeoJSON(self):
        # convert the route of a flight plan to a geojson feature collection
        # of waypoints and a line segment for the route.
        self.routeLS = LineString()
        self.route = FeatureCollection(features=[])

        for n in self.flight_plan["route"]["nodes"]:
            self.route.features.append(Feature(geometry=Point((n["lon"], n["lat"], n["alt"]*FOOT)), properties={
                "type": n["type"],
                "ident": n["ident"],
                "name": n["name"]
            }))
            self.routeLS.coordinates.append([n["lon"], n["lat"], n["alt"]*FOOT])


    def getGeoJSON(self, include_ls: bool = False):
        # fluke-ignore F841
        dummy = self.getFlightPlan()
        if self.route is not None:
            fc = FeatureCollection(features=self.route.features)  # .copy()
            if include_ls:
                fc.features.append(Feature(geometry=self.routeLS, properties={"tag": "route"}))
            return fc

        return None


    def getFlightPlan(self):
        if self.flight_plan is not None:
            return self.flight_plan

        ffp = os.path.join(self.flightplan_cache, self.filename + ".json")

        if os.path.exists(ffp):
            with open(ffp, "r") as file:
                self.flight_plan = json.load(file)
                self.toGeoJSON()
                logger.debug("getFlightPlan: %d from file cache %s" % (self.flight_plan["id"], ffp))

            return self.flight_plan

        return self.getFPDBFlightPlan()


    def getFPDBFlightPlan(self):
        fpid = None
        plans = self.api.user.plans(username="devleaks", limit=1000)
        # @todo should check for error status...

        for plan in plans:
            if fpid is None:
                if plan.fromICAO == self.fromICAO and plan.toICAO == self.toICAO:
                    fpid = plan.id

        if fpid is not None:  # cache it
            fp = self.api.plan.fetch(id_=fpid, return_format="json")
            # @todo should check for error status...
            self.flight_plan = json.loads(fp)
            logger.debug("getFPDBFlightPlan: %d from FPDB" % (self.flight_plan["id"]))
            self.cacheFlightPlan()
            return self.flight_plan

        return self.createFPDBFlightPlan()


    def cacheFlightPlan(self, geojson: bool = True):
        fn = os.path.join(self.flightplan_cache, self.filename + ".json")
        with open(fn, "w") as outfile:
            json.dump(self.flight_plan, outfile)
            logger.debug("%d now cached in file %s" % (self.flight_plan["id"], fn))
        if geojson:
            self.toGeoJSON()
            geo = self.getGeoJSON(include_ls=True)
            fngeo = os.path.join(self.flightplan_cache, self.filename + ".geojson")
            with open(fngeo, "w") as outfile:
                json.dump(geo, outfile)
                logger.debug("geojson %d now cached in file %s" % (self.flight_plan["id"], fngeo))

        logger.debug("%d now cached in file %s" % (self.flight_plan["id"], fn))
        self.cacheAirports()


    def createFPDBFlightPlan(self):
        plan_data = GenerateQuery(
            fromICAO=self.fromICAO,
            toICAO=self.toICAO
            #, # not used anyway...
            #cruiseAlt=self.cruiseAlt,
            #cruiseSpeed=self.cruiseSpeed,
            #ascentRate=self.ascentRate,
            #ascentSpeed=self.ascentSpeed,
            #descentRate=self.descentRate,
            #descentSpeed=self.descentSpeed
            )
        plan = self.api.plan.generate(plan_data)
        # @todo should check for error status... (or try/catch)
        if plan:
            fp = self.api.plan.fetch(id_=plan.id, return_format="json")
            # @todo should check for error status...
            self.flight_plan = json.loads(fp)
            logger.debug("createFPDBFlightPlan: new plan %d" % (self.flight_plan["id"]))
            self.cacheFlightPlan(geojson=True)
            return self.flight_plan

        return None


    def cacheAirports(self):
        """
        We cache airport data because it contains interesting information like elevation.
        """
        for f in [self.fromICAO, self.toICAO]:
            fn = os.path.join(self.airports_cache, f + ".json")
            if not os.path.exists(fn) or os.stat(fn).st_size == 0:
                aptresp = self.api.nav.airport(icao=f)
                apt = aptresp._to_api_dict()
                with open(fn, "w") as outfile:
                    json.dump(apt, outfile)
                    logger.debug("cacheAirports: new airport %s" % (f))


    def nodes(self):
        return self.flight_plan["route"]["nodes"]

    def toAirspace(self, airspace: Airspace):
        """
        Transform FeatureCollection<Feature<Point>> from FlightPlanDatabase into FeatureCollection<Feature<Vertex>>
        where Vertex is in Airspace.
        """
        def isPoint(f):
            return ("geometry" in f) and ("type" in f["geometry"]) and (f["geometry"]["type"] == "Point")

        wpts = []
        errs = 0
        idx = 0
        for f in self.route.features:
            if isPoint(f):
                fty = f["properties"]["type"] if "type" in f["properties"] else None
                fid = f["properties"]["ident"] if "ident" in f["properties"] else None
                if fid is not None:
                    wid = airspace.findControlledPointByName(fid)
                    if len(wid) == 1:
                        v = airspace.vert_dict[wid[0]]
                        wpts.append(v)
                        logger.debug(":toAirspace: added %s %s as %s" % (fty, fid, v.id))
                    else:
                        errs = errs + 1
                        if len(wid) == 0:
                            logger.warning(":toAirspace: ident %s not found" % fid)
                        else:
                            logger.warning(":toAirspace: ambiguous ident %s has %d entries" % (fid, len(wid)))
                            # @todo use proximity to previous point, choose closest. Use navaid rather than fix.
                            # if len(wpts) > 0:
                            #     logger.warning(":toVertices: will search for closest to previous %s" % wpts[-1])
                            #     wid2 = airspace.findClosestControlledPoint(wid, wpts[-1])  # returns (wpt, dist)
                            #     v = airspace.vert_dict[wid2[0]]
                            #     wpts.append(v)
                            #     logger.debug(":toVertices: added %s %s as %s (closest waypoint at %f)" % (fty, fid, v.id, wid2[1]))
                            # else
                            #     logger.warning(":toVertices: cannot eliminate ambiguous ident %s has %d entries" % (fid, len(wid)))
                else:
                    errs = errs + 1
                    logger.warning(":toAirspace: no ident for feature %s" % (fid))
        return (wpts, errs)
